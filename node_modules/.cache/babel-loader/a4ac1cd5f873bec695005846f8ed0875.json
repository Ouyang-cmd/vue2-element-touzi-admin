{"remainingRequest":"C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\node_modules\\thread-loader\\dist\\cjs.js!C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\src\\permission.js","dependencies":[{"path":"C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\src\\permission.js","mtime":1677382302046},{"path":"C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\babel.config.js","mtime":1677382256176},{"path":"C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\ou943\\Desktop\\pro-vue\\vue2-element-touzi-admin\\node_modules\\babel-loader\\lib\\index.js","mtime":456789000000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"C:/Users/ou943/Desktop/pro-vue/vue2-element-touzi-admin/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es6.function.name\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport router from \"./router\";\nimport store from \"./store\";\nimport NProgress from 'nprogress'; // Progress 进度条\nprocess.env.NODE_ENV === \"development\" && import('nprogress/nprogress.css');\nimport { Message } from 'element-ui';\nimport { getToken } from '@/utils/auth'; // 验权(从cookie中获取)\nimport { getUserInfo } from \"@/api/user\";\nimport { setTitle } from '@/utils/mUtils'; // 设置浏览器头部标题\n\nfunction hasPermission(roles, permissionRoles) {\n  if (roles.indexOf('admin') >= 0) return true;\n  if (!permissionRoles) return true;\n  return roles.some(function (role) {\n    return permissionRoles.indexOf(role) >= 0;\n  });\n}\nvar whiteList = ['/login']; // 不重定向白名单\n\nrouter.beforeEach(function (to, from, next) {\n  NProgress.start();\n  // 设置浏览器头部标题\n  var browserHeaderTitle = to.meta.title;\n  store.commit('SET_BROWSERHEADERTITLE', {\n    browserHeaderTitle: browserHeaderTitle\n  });\n  // 点击登录时，拿到了token并存入了cookie,保证页面刷新时,始终可以拿到token\n  if (getToken('Token')) {\n    if (to.path === '/login') {\n      next({\n        path: '/'\n      });\n      NProgress.done();\n    } else {\n      // 用户登录成功之后，每次点击路由都进行了角色的判断;\n      if (store.getters.roles.length === 0) {\n        var token = getToken('Token');\n        getUserInfo({\n          \"token\": token\n        }).then().then(function (res) {\n          // 根据token拉取用户信息\n          var userList = res.data.userList;\n          store.commit(\"SET_ROLES\", userList.roles);\n          store.commit(\"SET_NAME\", userList.name);\n          store.commit(\"SET_AVATAR\", userList.avatar);\n          store.dispatch('GenerateRoutes', {\n            \"roles\": userList.roles\n          }).then(function () {\n            // 根据roles权限生成可访问的路由表\n            router.addRoutes(store.getters.addRouters); // 动态添加可访问权限路由表\n            next(_objectSpread(_objectSpread({}, to), {}, {\n              replace: true\n            })); // hack方法 确保addRoutes已完成\n          });\n        }).catch(function (err) {\n          store.dispatch('LogOut').then(function () {\n            Message.error(err || 'Verification failed, please login again');\n            next({\n              path: '/'\n            });\n          });\n        });\n      } else {\n        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓\n        if (hasPermission(store.getters.roles, to.meta.roles)) {\n          next(); //\n        } else {\n          next({\n            path: '/401',\n            replace: true,\n            query: {\n              noGoBack: true\n            }\n          });\n        }\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) {\n      // 点击退出时,会定位到这里\n      next();\n    } else {\n      next('/login');\n      NProgress.done();\n    }\n  }\n});\nrouter.afterEach(function () {\n  NProgress.done(); // 结束Progress\n  setTimeout(function () {\n    var browserHeaderTitle = store.getters.browserHeaderTitle;\n    setTitle(browserHeaderTitle);\n  }, 0);\n});\n\n/**\r\n  本系统权限逻辑分析：\r\n  1、路由对象区分权限路由对象和非权限路由对象；初始化时，将非权限路由对象赋值给Router;同时设置权限路由中的meta对象，如:meta:{roles:['admin','editor']}\r\n     表示该roles所拥有的路由权限;\r\n  2、通过用户登录成功之后返回的roles值，进行路由的匹配并生成新的路由对象;\r\n  3、用户成功登录并跳转到首页时，根据刚刚生成的路由对象，渲染左侧的菜单;即，不同的用户看到的菜单是不一样的;\r\n  \r\n  用户点击登录和退出之后的业务逻辑分析：\r\n  1、用户点击登录按钮，通过路由导航钩子router.beforeEach()函数确定下一步的跳转逻辑,如下：\r\n   1.1、用户已经登录成功过，并从cookie中拿到了token值;\r\n     1.1.1、用户访问登录页面,直接定位到登录页面;\r\n     1.1.1、用户访问非登录页面,需要根据用户是否有roles信息，进行不同的业务逻辑,如下：\r\n        (1)、初始情况下,用户roles信息为空;\r\n            1.通过getUserInfo()函数,根据token拉取用户信息;并通过store将该用户roles,name,avatar信息存储于vuex;\r\n            2.通过store.dispatch('GenerateRoutes', { roles })去重新过滤和生成路由,通过router.addRoutes()合并路由表;   \r\n            3.如果在获取用户信息接口时出现错误，则调取store.dispatch('LogOut')接口,返回到login页面;\r\n          \r\n        (2)、用户已经拥有roles信息；\r\n            1.点击页面路由，通过roles权限判断 hasPermission()。如果用户有该路由权限，直接跳转对应的页面;如果没有权限，则跳转至401提示页面;\r\n  \r\n  2.用户点击退出,token已被清空\r\n    1.如果设置了白名单用户，则直接跳转到相应的页面;\r\n    2.反之,则跳转至登录页面;\r\n */",null]}